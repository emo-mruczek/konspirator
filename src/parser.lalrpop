// https://lalrpop.github.io/lalrpop/tutorial/002_paren_numbers.html

use std::str::FromStr;
use crate::ast::*;

grammar;

NUM: Num = {
  <s: r"[0-9]+"> => u64::from_str(s).unwrap(),
};

PID: PID = {
  <s: r"[_a-z]+"> => s.to_string(),
};

IDENTIFIER: Identifier = {
  <p: PID> => Identifier::Basic{name: p},
  <p: PID> "[" <n: NUM> "]" => Identifier::Array{name: p, size: n},
  <pl: PID> "[" <pr: PID> "]" => Identifier::VLA{name: pl, size: pr},
};

VALUE: Value = {
  <n: NUM> => Value::Num{val: n},
  <i: IDENTIFIER> => Value::Var{val: i},
};

CONDITION: Condition = {
  <lv: VALUE> "=" <rv: VALUE> => Condition::Equal{l: lv,r: rv},
  <lv: VALUE> "!=" <rv: VALUE> => Condition::NotEqual{l: lv,r: rv},
  <lv: VALUE> ">" <rv: VALUE> => Condition::Greater{l: lv,r: rv},
  <lv: VALUE> "<" <rv: VALUE> => Condition::Less{l: lv, r: rv},
  <lv: VALUE> ">=" <rv: VALUE> => Condition::GreaterEqual{ l: lv,r: rv},
  <lv: VALUE> "<=" <rv: VALUE> => Condition::LessEqual{l: lv,r: rv},
};

EXPRESSION: Expression = {
  <lv: VALUE> => Expression::Val {val: lv}, 
  <lv: VALUE> "+" <rv: VALUE> => Expression::Add {l: lv,r: rv}, 
  <lv: VALUE> "-" <rv: VALUE> => Expression::Sub {l: lv,r: rv}, 
  <lv: VALUE> "*" <rv: VALUE> => Expression::Mul {l: lv,r: rv}, 
  <lv: VALUE> "/" <rv: VALUE> => Expression::Div {l: lv,r: rv}, 
  <lv: VALUE> "%" <rv: VALUE> => Expression::Mod {l: lv,r: rv}, 
};

// https://lalrpop.github.io/lalrpop/tutorial/006_macros.html
ARGS: Args = {
  <mut v:(<PID> ",")*> <e: PID?> => match e {
    None => v,
    Some(e) => {
      v.push(e);
      return v;
    }
  },
};

ARGSDECL: ArgsDecl = {
  <mut v: ARGSDECL> "," <p: PID> => {
    v.push(ArgDecl::Basic{name: p});
    return v;
  },
  <mut v: ARGSDECL> "," "T" <p: PID> => {
    v.push(ArgDecl::Tab{name: p});
    return v;
  },
  <p: PID> => vec![ArgDecl::Basic{name: p}],
  "T" <p: PID> => vec![ArgDecl::Tab{name: p}],
};

DECLARATIONS: Declarations = {
  <mut v:DECLARATIONS> "," <p: PID> => {
    v.push(Declaration::Basic{name: p});
    return v;
  },
  <mut v:DECLARATIONS> "," <p: PID> "[" <n: NUM> "]" => {
    v.push(Declaration::Array{name: p, num: n});
    return v;
  },
  <p: PID> => vec![Declaration::Basic{name: p}],
  <p: PID> "[" <n: NUM> "]" => vec![Declaration::Array{name: p, num: n}],
};

PROCCALL: ProcCall = {
  <p: PID> "(" <a: ARGS> ")" => ProcCall{name: p, args: a},
};

PROCHEAD: ProcHead = {
  <p: PID> "(" <a: ARGSDECL> ")" => ProcHead{name: p, args_decl: a},
};

COMMAND: Command = {
  <i: IDENTIFIER> ":=" <e: EXPRESSION> ";" => Command::Assign{name: i, expr: e},
  "IF" <c: CONDITION> "THEN" <coml: COMMANDS> "ELSE" <comr: COMMANDS> "ENDIF" => Command::If{cond: c, comm: coml, else_comm: Some(comr)},
  "IF" <c: CONDITION> "THEN" <com: COMMANDS> "ENDIF" => Command::If{cond: c, comm: com, else_comm: None},
  "WHILE" <c: CONDITION> "DO" <com: COMMANDS> "ENDWHILE" => Command::While{cond: c, comm: com},
  "REPEAT" <com: COMMANDS> "UNTIL" <c: CONDITION> ";" => Command::Repeat{comm: com, cond: c},
  <p: PROCCALL> ";" => Command::Call{call: p},
  "READ" <i: IDENTIFIER> ";" => Command::Read{name: i},
  "WRITE" <v: VALUE> ";" => Command::Write{val: v}, 
};

COMMANDS: Commands = {
  <mut v: COMMANDS> <c: COMMAND> => {
    v.push(c);
    return v;
  },
  <c: COMMAND> => vec![c],
};

MAIN: Main = {
  "PROGRAM" "IS" <d: DECLARATIONS?> "IN" <c: COMMANDS> "END" => Main{declarations: d, commands: c}, 
};

PROCEDURES: Procedures = {
  <mut p: PROCEDURES> "PROCEDURE" <pc: PROCHEAD> "IS" <d: DECLARATIONS?> "IN" <c: COMMANDS> "END" => {
    p.push(Procedure{proc_head: pc, declarations: d, commands: c});
    return p;
  },
  "PROCEDURE" <pc: PROCHEAD> "IS" <d: DECLARATIONS?> "IN" <c: COMMANDS> "END" => vec![Procedure{proc_head: pc, declarations: d, commands: c}],
};

pub PROGRAMALL: ProgramAll = {
  <p: PROCEDURES?> <m: MAIN> => ProgramAll{ procedures: p, main: m},
};

match {
    "+",
    "-",
    "*",
    "/",
    "%",
    "=",
    "!=",
    ">",
    "<",
    ">=",
    "<=",
    ",",
    "T",
    r"[0-9]+",
    r"[_a-z]+",
    "[",
    "]",
    "(",
    ")",
    ":=",
    "IF",
    "THEN",
    "ELSE",
    "ENDIF",
    "WHILE",
    "DO",
    "ENDWHILE",
    "REPEAT",
    "UNTIL",
    ";",
    "READ",
    "WRITE",
    "PROGRAM",
    "IS",
    "IN",
    "END",
    "PROCEDURE",
    "\n" => {}, // prob unnecessary
    r"\s*" => {}, // whitespaces
    r"#[^\n\r]*[\n\r]*" => {}, // comments
}
